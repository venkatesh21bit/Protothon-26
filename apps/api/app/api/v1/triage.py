"""
Triage API Routes
Voice Triage Module with watsonx Orchestrate Integration

This module provides:
1. Patient frontend endpoints (audio recording, survey submission)
2. Agent API endpoints for IBM watsonx Orchestrate
3. Admin/nurse endpoints for case management

OpenAPI documentation is auto-generated by FastAPI for Orchestrate integration.
"""
import logging
from datetime import datetime
from typing import Optional, List
from fastapi import APIRouter, HTTPException, UploadFile, File, Form, Query, Body
from fastapi.responses import JSONResponse

from app.schemas.triage import (
    AppointmentCreate,
    AppointmentResponse,
    SurveyResponseSubmit,
    SurveyResponseResult,
    VoiceTriageRequest,
    VoiceTriageResponse,
    TriageCaseCreate,
    TriageCaseResponse,
    TriageCaseUpdate,
    UrgentCasesResponse,
    UrgentCaseItem,
    MarkCaseSeenRequest,
    MarkCaseSeenResponse,
    TriageHealthCheck,
    SeverityLevel
)
from app.services.ibm.triage_engine import triage_engine
from app.services.ibm.cloudant import cloudant_service

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/triage", tags=["Voice Triage & Orchestrate"])


# ==================== HEALTH CHECK ====================

@router.get(
    "/health",
    response_model=TriageHealthCheck,
    summary="Triage Module Health Check",
    description="Check the health status of all triage-related services"
)
async def triage_health_check():
    """Health check for triage module and its dependencies"""
    return TriageHealthCheck(
        status="healthy",
        services={
            "cloudant": True,
            "nlu": True,
            "speech_to_text": True,
            "email": True
        },
        timestamp=datetime.utcnow().isoformat()
    )


# ==================== PATIENT FRONTEND ENDPOINTS ====================

@router.post(
    "/appointments",
    response_model=AppointmentResponse,
    summary="Book Appointment (Triggers Triage Workflow)",
    description="""
    Create a new appointment and automatically trigger the triage workflow.
    
    **Workflow Steps:**
    1. Creates appointment record in Cloudant
    2. Generates personalized pre-consultation survey
    3. Sends survey email to patient
    4. Returns appointment and survey IDs
    
    This is the entry point for the autonomous patient intake system.
    """
)
async def create_appointment(appointment: AppointmentCreate):
    """
    Book an appointment - triggers the autonomous triage workflow
    """
    try:
        result = await triage_engine.process_appointment_booking(
            patient_id=appointment.patient_id,
            patient_name=appointment.patient_name,
            patient_email=appointment.patient_email,
            doctor_id=appointment.doctor_id,
            doctor_name=appointment.doctor_name,
            appointment_date=appointment.appointment_date,
            appointment_time=appointment.appointment_time,
            reason=appointment.reason
        )
        
        if not result.get("success"):
            raise HTTPException(status_code=500, detail=result.get("error"))
        
        return AppointmentResponse(**result)
        
    except Exception as e:
        logger.error(f"Error creating appointment: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post(
    "/surveys/respond",
    response_model=SurveyResponseResult,
    summary="Submit Survey Response",
    description="""
    Submit a patient's response to the pre-consultation survey.
    
    **Processing Steps:**
    1. Extracts medical entities using IBM Watson NLU
    2. Calculates severity score
    3. Detects red flag symptoms
    4. Updates EHR database
    5. Alerts nurse station if HIGH severity
    """
)
async def submit_survey_response(response: SurveyResponseSubmit):
    """
    Process patient's survey response through NLU pipeline
    """
    try:
        result = await triage_engine.process_survey_response(
            survey_id=response.survey_id,
            response_text=response.response_text,
            answers=response.answers
        )
        
        if not result.get("success"):
            raise HTTPException(status_code=400, detail=result.get("error"))
        
        return SurveyResponseResult(**result)
        
    except Exception as e:
        logger.error(f"Error processing survey response: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post(
    "/voice",
    response_model=VoiceTriageResponse,
    summary="Submit Voice Recording for Triage",
    description="""
    Process a voice recording through the complete triage pipeline.
    
    **Pipeline Steps:**
    1. **Speech-to-Text**: IBM Watson converts audio to transcript
    2. **NLU Processing**: Extracts symptoms, medications, entities
    3. **Severity Assessment**: Calculates HIGH/MEDIUM/LOW severity
    4. **Red Flag Detection**: Identifies critical symptoms
    5. **EHR Update**: Stores structured data in patient record
    6. **Nurse Alert**: Sends alert if HIGH severity with red flags
    
    **Supported Audio Formats:**
    - audio/webm (recommended for browser recording)
    - audio/wav
    - audio/mp3
    - audio/ogg
    
    **Supported Languages:**
    - en-IN (Indian English) - default
    - en-US (US English)
    - hi-IN (Hindi)
    """
)
async def process_voice_triage(
    audio: UploadFile = File(..., description="Audio file from patient recording"),
    patient_id: str = Form(..., description="Patient identifier"),
    patient_name: str = Form(..., description="Patient's full name"),
    language: str = Form(default="en-IN", description="Language code"),
    appointment_id: Optional[str] = Form(default=None, description="Optional linked appointment ID")
):
    """
    Process voice input through the complete triage pipeline
    """
    try:
        # Read audio data
        audio_data = await audio.read()
        content_type = audio.content_type or "audio/webm"
        
        logger.info(f"Received audio: {len(audio_data)} bytes, type: {content_type}")
        
        result = await triage_engine.process_voice_input(
            patient_id=patient_id,
            patient_name=patient_name,
            audio_data=audio_data,
            content_type=content_type,
            language=language,
            appointment_id=appointment_id
        )
        
        return VoiceTriageResponse(**result)
        
    except Exception as e:
        logger.error(f"Error processing voice triage: {e}")
        return VoiceTriageResponse(
            success=False,
            error=str(e)
        )


# ==================== ORCHESTRATE API ENDPOINTS ====================
# These endpoints are designed for IBM watsonx Orchestrate integration
# The OpenAPI spec for these endpoints can be exported for Orchestrate

@router.get(
    "/api/urgent-cases",
    response_model=UrgentCasesResponse,
    summary="Get Urgent Cases (Orchestrate API)",
    description="""
    **For IBM watsonx Orchestrate Integration**
    
    Returns all urgent (HIGH severity) triage cases that haven't been seen.
    
    This endpoint is called by the AI agent when a doctor asks:
    - "Do we have any urgent patients waiting?"
    - "Any critical cases I should know about?"
    - "Show me the urgent triage list"
    
    **Response includes:**
    - Count of urgent cases
    - Detailed information for each case
    - Human-readable summaries for the AI agent
    
    **OpenAPI Spec:**
    Export this endpoint's OpenAPI spec and upload to watsonx Orchestrate
    to enable the agent to "know" how to check for urgent cases.
    """,
    responses={
        200: {
            "description": "List of urgent triage cases",
            "content": {
                "application/json": {
                    "example": {
                        "count": 2,
                        "cases": [
                            {
                                "case_id": "triage_abc123",
                                "patient_id": "101",
                                "patient_name": "John Doe",
                                "severity": "HIGH",
                                "red_flags": ["breathing trouble"],
                                "symptoms": ["cough", "shortness of breath"],
                                "created_at": "2024-01-15T10:30:00Z",
                                "status": "pending",
                                "summary": "Patient John Doe has breathing trouble."
                            }
                        ],
                        "retrieved_at": "2024-01-15T11:00:00Z"
                    }
                }
            }
        }
    }
)
async def get_urgent_cases():
    """
    GET /api/urgent-cases - Orchestrate endpoint
    
    Returns all HIGH severity cases that need immediate attention.
    This is the primary endpoint for watsonx Orchestrate integration.
    """
    try:
        cases = await triage_engine.get_urgent_cases()
        
        urgent_items = [
            UrgentCaseItem(
                case_id=c["case_id"],
                patient_id=c["patient_id"],
                patient_name=c["patient_name"],
                severity=SeverityLevel(c["severity"]),
                red_flags=c["red_flags"],
                symptoms=c["symptoms"],
                created_at=c["created_at"],
                status=c["status"],
                summary=c["summary"]
            )
            for c in cases
        ]
        
        return UrgentCasesResponse(
            count=len(urgent_items),
            cases=urgent_items,
            retrieved_at=datetime.utcnow().isoformat()
        )
        
    except Exception as e:
        logger.error(f"Error fetching urgent cases: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post(
    "/api/cases/{case_id}/seen",
    response_model=MarkCaseSeenResponse,
    summary="Mark Case as Seen (Orchestrate API)",
    description="""
    **For IBM watsonx Orchestrate Integration**
    
    Mark a triage case as seen by the doctor.
    
    The AI agent calls this when a doctor says:
    - "Mark patient 101 as seen"
    - "I've reviewed the urgent case"
    - "Yes, mark them as seen"
    
    **Parameters:**
    - case_id: The triage case ID to mark as seen
    - doctor_notes: Optional notes from the doctor
    """
)
async def mark_case_as_seen(
    case_id: str,
    request: MarkCaseSeenRequest = Body(None)
):
    """
    Mark a triage case as seen - used by Orchestrate agent
    """
    try:
        doctor_notes = request.doctor_notes if request else None
        
        result = await triage_engine.mark_case_seen(
            case_id=case_id,
            doctor_notes=doctor_notes
        )
        
        if not result.get("success"):
            raise HTTPException(status_code=404, detail="Case not found")
        
        return MarkCaseSeenResponse(
            success=True,
            case_id=case_id,
            status="seen",
            updated_at=result["updated_at"],
            message=f"Case {case_id} has been marked as seen."
        )
        
    except Exception as e:
        logger.error(f"Error marking case as seen: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get(
    "/api/cases/{case_id}",
    response_model=TriageCaseResponse,
    summary="Get Case Details (Orchestrate API)",
    description="""
    **For IBM watsonx Orchestrate Integration**
    
    Get detailed information about a specific triage case.
    
    The AI agent calls this when asked:
    - "Tell me more about case ABC123"
    - "What are the details for patient John's case?"
    """
)
async def get_case_details(case_id: str):
    """
    Get detailed information about a triage case
    """
    try:
        case = await triage_engine.get_case_details(case_id)
        
        if not case:
            raise HTTPException(status_code=404, detail="Case not found")
        
        return TriageCaseResponse(
            case_id=case["_id"],
            patient_id=case["patient_id"],
            patient_name=case["patient_name"],
            symptoms=case.get("symptoms", []),
            medications=case.get("medications", []),
            transcript=case.get("transcript"),
            severity_score=SeverityLevel(case["severity_score"]),
            red_flags=case.get("red_flags", []),
            status=case["status"],
            created_at=case["created_at"],
            updated_at=case["updated_at"],
            nurse_alerted=case.get("nurse_alerted", False),
            doctor_notes=case.get("doctor_notes")
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error fetching case details: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get(
    "/api/cases",
    summary="List Cases by Severity (Orchestrate API)",
    description="""
    **For IBM watsonx Orchestrate Integration**
    
    List triage cases filtered by severity level.
    
    The AI agent calls this when asked:
    - "Show me all medium priority cases"
    - "How many low priority patients are waiting?"
    """
)
async def list_cases_by_severity(
    severity: SeverityLevel = Query(..., description="Filter by severity: HIGH, MEDIUM, or LOW")
):
    """
    List all triage cases filtered by severity level
    """
    try:
        cases = await triage_engine.get_cases_by_severity(severity.value)
        
        return {
            "severity": severity,
            "count": len(cases),
            "cases": [
                {
                    "case_id": c.get("_id"),
                    "patient_name": c.get("patient_name"),
                    "symptoms": c.get("symptoms", []),
                    "red_flags": c.get("red_flags", []),
                    "status": c.get("status"),
                    "created_at": c.get("created_at")
                }
                for c in cases
            ]
        }
        
    except Exception as e:
        logger.error(f"Error listing cases: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ==================== ADMIN/NURSE ENDPOINTS ====================

@router.post(
    "/cases",
    response_model=TriageCaseResponse,
    summary="Create Manual Triage Case",
    description="Create a triage case manually (bypassing voice/survey workflow)"
)
async def create_manual_triage_case(case_data: TriageCaseCreate):
    """
    Create a triage case manually for walk-in patients or emergencies
    """
    try:
        # Create extraction dict from provided data
        extracted_entities = {
            "symptoms": case_data.symptoms,
            "medications": case_data.medications,
            "conditions": [],
            "allergies": []
        }
        
        result = await triage_engine.create_triage_case(
            patient_id=case_data.patient_id,
            patient_name=case_data.patient_name,
            transcript=case_data.notes,
            extracted_entities=extracted_entities,
            appointment_id=case_data.appointment_id
        )
        
        # Fetch the created case
        case = await triage_engine.get_case_details(result["case_id"])
        
        return TriageCaseResponse(
            case_id=case["_id"],
            patient_id=case["patient_id"],
            patient_name=case["patient_name"],
            symptoms=case.get("symptoms", []),
            medications=case.get("medications", []),
            transcript=case.get("transcript"),
            severity_score=SeverityLevel(case["severity_score"]),
            red_flags=case.get("red_flags", []),
            status=case["status"],
            created_at=case["created_at"],
            updated_at=case["updated_at"],
            nurse_alerted=case.get("nurse_alerted", False),
            doctor_notes=case.get("doctor_notes")
        )
        
    except Exception as e:
        logger.error(f"Error creating manual case: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.patch(
    "/cases/{case_id}",
    response_model=TriageCaseResponse,
    summary="Update Triage Case",
    description="Update status or add notes to a triage case"
)
async def update_triage_case(case_id: str, update: TriageCaseUpdate):
    """
    Update a triage case (status, doctor notes, etc.)
    """
    try:
        if update.status:
            case = await cloudant_service.update_case_status(
                case_id=case_id,
                status=update.status.value,
                doctor_notes=update.doctor_notes
            )
        else:
            case = await triage_engine.get_case_details(case_id)
            if not case:
                raise HTTPException(status_code=404, detail="Case not found")
        
        return TriageCaseResponse(
            case_id=case["_id"],
            patient_id=case["patient_id"],
            patient_name=case["patient_name"],
            symptoms=case.get("symptoms", []),
            medications=case.get("medications", []),
            transcript=case.get("transcript"),
            severity_score=SeverityLevel(case["severity_score"]),
            red_flags=case.get("red_flags", []),
            status=case["status"],
            created_at=case["created_at"],
            updated_at=case["updated_at"],
            nurse_alerted=case.get("nurse_alerted", False),
            doctor_notes=case.get("doctor_notes")
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error updating case: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ==================== OPENAPI SPEC ENDPOINT ====================

@router.get(
    "/openapi.json",
    summary="Get OpenAPI Spec for Orchestrate",
    description="""
    Returns the OpenAPI specification for this API.
    
    **Usage with watsonx Orchestrate:**
    1. Call this endpoint to get the OpenAPI JSON
    2. Go to watsonx Orchestrate > Add a Tool
    3. Upload the JSON file
    4. The agent will now "know" how to check for urgent cases
    
    **Key endpoints for Orchestrate:**
    - GET /api/urgent-cases - Check for urgent patients
    - POST /api/cases/{case_id}/seen - Mark case as seen
    - GET /api/cases/{case_id} - Get case details
    """,
    include_in_schema=False
)
async def get_openapi_spec():
    """
    Returns the OpenAPI spec for this router for Orchestrate import
    """
    from fastapi.openapi.utils import get_openapi
    from app.main import app
    
    openapi_schema = get_openapi(
        title="Nidaan Voice Triage API",
        version="1.0.0",
        description="Voice Triage Module for IBM watsonx Orchestrate Integration",
        routes=app.routes
    )
    
    return JSONResponse(content=openapi_schema)
